<?xml version="1.0" encoding="UTF-8"?> <rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"> <channel><title>Ho</title><description>Slow &amp; Steady 💻</description><link>http://localhost:4000/</link><atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/><pubDate>Wed, 22 Jun 2022 22:24:34 +0900</pubDate> <lastBuildDate>Wed, 22 Jun 2022 22:24:34 +0900</lastBuildDate> <generator>Jekyll v4.2.2</generator> <item><title>[Spring] Spring - Servlet &amp; JSP (1)</title><description>&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/64628448/173368063-e326ec44-d5c9-4932-afaa-9fab1b072633.png&quot; alt=&quot;spring&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt; &lt;h1 id=&quot;-introduction&quot;&gt;📚 Introduction&lt;/h1&gt; &lt;p&gt;Servlet &amp;amp; JSP &lt;br /&gt;&lt;/p&gt; &lt;h1 id=&quot;servlet-이란&quot;&gt;Servlet 이란?&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;자바를 사용하여 웹을 만들기 위해 필요한 기술.&lt;br /&gt;&lt;/li&gt; &lt;li&gt; &lt;p&gt;일반적으로 웹서버는 정적인 페이지만 제공. &lt;br /&gt; 웹 서버가 동적인 페이지를 제공할 수 있도록 도와주는 Application이 Servlet이며, 동적인 페이지를 생성하는 Application이 CGI다.&lt;br /&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt;서블릿의 생명주기 (Life Cycle) → &lt;br /&gt; 웹 애플리케이션 컨테이너에서 콘텍스트가 초기화되면 생명주기가 시작된다.&lt;br /&gt; &lt;ol&gt; &lt;li&gt;초기화 (initialize)&lt;br /&gt;&lt;/li&gt; &lt;li&gt;서비스 (service)&lt;br /&gt;&lt;/li&gt; &lt;li&gt;소멸 (destroy)&lt;br /&gt;&lt;br /&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;서블릿의 동작방식 → &lt;br /&gt; &lt;ol&gt; &lt;li&gt;사용자(클라이언트)가 URL을 치고 엔터치면 HTTP Request를 Servlet Container로 전송.&lt;br /&gt;&lt;/li&gt; &lt;li&gt;Servlet Contatiner는 HttpServletRequest, HttpServletResponse 두 객체 생성.&lt;br /&gt;&lt;/li&gt; &lt;li&gt;web.xml은 사용자가 요청한 URL을 분석하여 어느 서블릿에 대해 요청을 한 것인지 찾는다.&lt;br /&gt;&lt;/li&gt; &lt;li&gt;해당 서블릿에서 service 메소드를 호출한 후 클라이언트의 POST, GET 여부에 따라 doGet() 또는 doPost()를 호출한다.&lt;br /&gt;&lt;/li&gt; &lt;li&gt;doGet(), doPost()는 동적 페이지를 생성한 후 HttpServletResponse 객체에 응답을 보낸다.&lt;br /&gt;&lt;/li&gt; &lt;li&gt;응답이 끝나면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킨다.&lt;br /&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;img width=&quot;853&quot; alt=&quot;ServletEx&quot; src=&quot;https://user-images.githubusercontent.com/64628448/175036132-c3b74196-6bfc-49bb-9ff0-6deac23d31fe.png&quot; /&gt;&lt;br /&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;@WebServlet = @Controller + @RequestMapping. 그리고 HttpServlet을 상속받는다. &lt;br /&gt;&lt;/li&gt; &lt;li&gt;Servlet : 기본적으로 singleton. (1개의 인스턴스로 재활용.) &lt;br /&gt;&lt;/li&gt; &lt;li&gt; &lt;p&gt;Spring도 마찬가지로 하나의 인스턴스로 여러 요청을 처리함.&lt;br /&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt;Servlet의 기본 객체 -&amp;gt; &lt;img width=&quot;1004&quot; alt=&quot;servletDefault&quot; src=&quot;https://user-images.githubusercontent.com/64628448/175036960-fdbfebea-a336-474d-a73a-1dfb66092a43.png&quot; /&gt;&lt;br /&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h1 id=&quot;cgi-common-gateway-interface-란&quot;&gt;CGI (Common Gateway Interface) 란?&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;웹 서버와 요청을 받아 처리해줄 로직을 담고있는 애플리케이션 프로그램 사이의 인터페이스. &lt;br /&gt;&lt;/li&gt; &lt;li&gt;CGI가 비효율적이라 나온 것이 Servlet.&lt;br /&gt; &lt;img width=&quot;584&quot; alt=&quot;CGI&quot; src=&quot;https://user-images.githubusercontent.com/64628448/175035948-2f783353-811c-46cd-83b6-f5543a52ddb9.png&quot; /&gt;&lt;br /&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h1 id=&quot;jsp-java-servlet-page-란&quot;&gt;JSP (Java Servlet Page) 란?&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;HTML 코드에 Java 코드를 넣어 동적 웹페이지를 생성하는 Web Application 도구이다.&lt;br /&gt;&lt;/li&gt; &lt;li&gt;JSP가 실행되면, 자바 서블릿으로 변환되고, 웹 어플리케이션 서버에서 동작되면서 필요한 기능을 수행한 후, 생성된 데이터를 웹 페이지와 함께 클라이언트로 응답한다. &lt;br /&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h1 id=&quot;jsp의-호출-과정&quot;&gt;JSP의 호출 과정&lt;/h1&gt; &lt;p&gt;&lt;img width=&quot;435&quot; alt=&quot;jsp(1)&quot; src=&quot;https://user-images.githubusercontent.com/64628448/175037402-d28f7fa8-7091-4575-b950-4bbd389ed495.png&quot; /&gt; &lt;br /&gt; &lt;img width=&quot;308&quot; alt=&quot;jsp(2)&quot; src=&quot;https://user-images.githubusercontent.com/64628448/175037442-f7c10442-5a08-4b57-9f0c-7d9fe73f159e.png&quot; /&gt; &lt;br /&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;JSP가 실행되면 WAS는 내부적으로 JSP 파일을 Java Servlet(.java)으로 변환한다.&lt;br /&gt;&lt;/li&gt; &lt;li&gt;WAS는 이 변환한 Servlet을 동작하여 필요한 기능을 수행한다.&lt;br /&gt; &lt;ol&gt; &lt;li&gt;WAS는 사용자 요청에 맞는 적절한 Servlet 파일을 컴파일(.class 파일 생성)한다.&lt;br /&gt;&lt;/li&gt; &lt;li&gt;.class 파일을 메모리에 올려 Servlet 객체를 만든다.&lt;br /&gt;&lt;/li&gt; &lt;li&gt;메모리에 로드될 때 Servlet 객체를 초기화하는 init() 메서드가 실행된다.&lt;br /&gt;&lt;/li&gt; &lt;li&gt;WAS는 Request가 올 때마다 thread를 생성하여 처리한다.&lt;br /&gt;&lt;/li&gt; &lt;li&gt;각 thread는 Servlet의 단일 객체에 대한 service() 메서드를 실행한다.&lt;br /&gt;&lt;/li&gt; &lt;li&gt;service() 메서드는 요청에 맞는 적절한 메서드(doGet, doPost 등)를 호출한다.&lt;br /&gt; 수행 완료 후 생성된 데이터를 웹 페이지와 함께 클라이언트로 응답한다.&lt;br /&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;유효범위와 속성 &lt;br /&gt; ServletContext에는 pageContext라는 지역변수와 application라는 공통저장소가 존재. &lt;br /&gt; -&amp;gt; pageContext는 요청 하나만 처리하고 초기화, application은 공용으로 사용하기에 여러 클라이언트의 요청을 저장하기에 부적합.&lt;br /&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;따라서 session을 사용.&lt;br /&gt; session = 각 클라이언트마다 갖는 개별 저장소라고 보면 됨.&lt;br /&gt; –&amp;gt; session객체는 서버부담이 제일 크기 때문에 최소한의 클라이언트 정보만 저장하는 것이 좋음.&lt;br /&gt; –&amp;gt; 페이지들 간에 데이터 전달이 필요하다면 request객체 사용.&lt;br /&gt;&lt;/p&gt; &lt;p&gt;&lt;img width=&quot;1049&quot; alt=&quot;servletDefault(2)&quot; src=&quot;https://user-images.githubusercontent.com/64628448/175037970-9d739c45-49e0-46a4-9d9f-d79292dd1fd2.png&quot; /&gt;&lt;br /&gt;&lt;/p&gt; &lt;p&gt;💡&lt;/p&gt; </description><pubDate>Wed, 22 Jun 2022 22:22:57 +0900</pubDate><link>http://localhost:4000/posts/spring-servlet&jsp/</link><guid isPermaLink="true">http://localhost:4000/posts/spring-servlet&jsp/</guid> <category>spring</category> <category>Study</category> <category>Spring</category> </item> <item><title>[Spring] Spring - MVC(1)</title><description>&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/64628448/173368063-e326ec44-d5c9-4932-afaa-9fab1b072633.png&quot; alt=&quot;spring&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt; &lt;h1 id=&quot;-introduction&quot;&gt;📚 Introduction&lt;/h1&gt; &lt;p&gt;Spring MVC에 대해 간단히 알아보자. &lt;br /&gt;&lt;/p&gt; &lt;h1 id=&quot;1-관심사의-분리&quot;&gt;1. 관심사의 분리&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;객체지향 5대 원칙 (SOLID). &lt;br /&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h1 id=&quot;solid-원칙이란-&quot;&gt;SOLID 원칙이란 ?&lt;/h1&gt; &lt;p&gt;(1) SRP (Single Responsibility Principle) (단일 책임 원칙) &lt;br /&gt; → 소프트웨어의 설계 부품(클래스, 함수 등) 은 단 하나의 책임(기능) 만을 가져야 한다. &lt;br /&gt;&lt;br /&gt; (2) OCP (Open-Closed Principle) ( 개방-폐쇄 원칙 ) &lt;br /&gt; → 기존의 코드를 변경하지 않고 (Closed) , 기능을 수정하거나 추가할 수 있도록 (Open) 설계해야 한다. &lt;br /&gt; → 자주 변경되는 내용은 수정하기 쉽게 설계하고, 변경되면 안되는 것들은 수정되는 내용에 영향을 받지 않게 설계해야 한다. &lt;br /&gt;&lt;br /&gt; (3) LSP (Liskov Substitution Principle) (리스코프 치환 원칙) ( 다형성 ) &lt;br /&gt; → 자식 클래스는 부모 클래스에서 가능한 행위를 수행할 수 있어야 한다. &lt;br /&gt; → 부모 클래스의 인스턴스 대신 자식클래스의 인스턴스를 사용할 수 있어야 한다. &lt;br /&gt;&lt;br /&gt; (4) ISP (Interface Segregation Principle) (인터페이스 분리 원칙) &lt;br /&gt; → 한 클래스는 자신이 사용하지 않은 인터페이스는 구현하지 말아야 한다. 하나의 일반적인 인터페이스보다는 여러개의 구체적인 인터페이스가 더 낫다. &lt;br /&gt; → 자신이 사용하지 않는 기능에 대해서는 서로에게 영향을 받지 않도록 설계해야 한다. &lt;br /&gt;&lt;br /&gt; (5) DIP (Dependency Inversion Principle) (의존 역전 원칙) ( 의존성 주입 ) &lt;br /&gt; → 의존관계를 맺을 때, 변화하기 쉬운 것 보다 변화하기 어려운 것에 의존해야 한다. &lt;br /&gt; → 변화하기 쉬운 것 → 구체적인 것, 변화하기 어려운 것 → 추상적인 것. &lt;br /&gt; → DIP를 만족한다는 것은, 의존관계를 맺을 때, 구체적인 클래스보다 인터페이스나 추상클래스와 관계를 맺는다는 것을 의미한다. &lt;br /&gt;&lt;/p&gt; &lt;h1 id=&quot;2-공통코드의-분리-입력의-분리&quot;&gt;2. 공통코드의 분리 (입력의 분리)&lt;/h1&gt; &lt;p&gt;기존에는 파라미터를 HttpServletRequest의 request 객체를 받았지만, &lt;br /&gt; &lt;img width=&quot;788&quot; alt=&quot;yoilBeforeMVC&quot; src=&quot;https://user-images.githubusercontent.com/64628448/174235547-74901a21-7910-412b-aff3-ff3c99188327.png&quot; /&gt; &lt;br /&gt; 분리를 한다는 가정하에, request 객체에 담겨있던 파라미터들을 타입과 함께 그 자체로 받는다. &lt;br /&gt; &lt;img width=&quot;750&quot; alt=&quot;yoilAfterMVC&quot; src=&quot;https://user-images.githubusercontent.com/64628448/174236350-d66f4a64-eb44-444c-a6d2-b18c97281404.png&quot; /&gt; &lt;br /&gt; 이렇게 하는 이유는..? &lt;br /&gt; 단순히 입력연산을 생략시키기 위해?? –&amp;gt; 추후에 뭔지 찾아보기.&lt;/p&gt; &lt;h1 id=&quot;3-출력의-분리-변하는-것과-변하지-않는-것의-분리&quot;&gt;3. 출력의 분리 (변하는 것과 변하지 않는 것의 분리)&lt;/h1&gt; &lt;p&gt;영역이 분리되면서, 받은 파라미터를 각 영역에서 사용할 수 없음. -&amp;gt; Model객체에 담아서 각 영역끼리 서로 주고받게 끔 함. &lt;br /&gt; (*) view 경로 지정 =&amp;gt; dispatcher-servlet.xml &lt;br /&gt; &lt;img width=&quot;687&quot; alt=&quot;viewPath&quot; src=&quot;https://user-images.githubusercontent.com/64628448/174241428-35b5721c-79ac-43cd-90e6-b68ff324c144.png&quot; /&gt; &lt;br /&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;컨트롤러 메서드의 반환타입 &lt;br /&gt; (1) String -&amp;gt; view 이름을 반환. &lt;br /&gt; (2) void -&amp;gt; 맵핑된 url의 끝단어가 뷰이름. &lt;br /&gt; (3) ModelAndView -&amp;gt; Model과 view이름을 반환. &lt;br /&gt;&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;💡&lt;/p&gt; </description><pubDate>Fri, 17 Jun 2022 15:48:57 +0900</pubDate><link>http://localhost:4000/posts/spring-mvc(1)/</link><guid isPermaLink="true">http://localhost:4000/posts/spring-mvc(1)/</guid> <category>http</category> <category>spring</category> <category>Study</category> <category>Http</category> <category>Spring</category> </item> <item><title>[Spring] Spring - HTTP(2)</title><description>&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/64628448/173368063-e326ec44-d5c9-4932-afaa-9fab1b072633.png&quot; alt=&quot;spring&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt; &lt;h1 id=&quot;-introduction&quot;&gt;📚 Introduction&lt;/h1&gt; &lt;p&gt;protocol, http에 대해 간략히 정리.&lt;/p&gt; &lt;h1 id=&quot;프로토콜protocol-이란&quot;&gt;프로토콜(Protocol) 이란?&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;클라이언트와 서버 서로 간의 통신을 위한 약속, 규칙. &lt;br /&gt;&lt;/li&gt; &lt;li&gt;주고 받을 데이터에 대한 형식을 정의한 것. &lt;br /&gt; ex) 편지(business letter), 편지봉투. &lt;br /&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h1 id=&quot;httphyper-text-transfer-protocol-란&quot;&gt;HTTP(Hyper Text Transfer Protocol) 란?&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;텍스트 기반의 프로토콜. &lt;br /&gt;&lt;/li&gt; &lt;li&gt;상태를 유지하지 않는다.(stateless) -&amp;gt; 클라이언트 정보를 저장하지 않는다. -&amp;gt; 이를 보완하기 위해 쿠키와 세션을 사용한다. &lt;br /&gt;&lt;/li&gt; &lt;li&gt;확장이 가능하다 -&amp;gt; 커스텀 헤더(header) 추가가 가능하다. &lt;br /&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h1 id=&quot;http-메서드&quot;&gt;HTTP 메서드&lt;/h1&gt; &lt;ol&gt; &lt;li&gt; &lt;p&gt;GET &lt;br /&gt; (1-1). 서버의 리소스를 가져오기 위해 설계. &lt;br /&gt; (1-2). queryString을 통해 데이터를 전달.(소용량) &lt;br /&gt; (1-3). URL에 데이터가 노출되므로 보안에 취약하다.&lt;br /&gt; (1-4). 데이터 공유에 상대적으로 유리. &lt;br /&gt; ex) 검색엔진에서 검색단어 전송에 이용. &lt;br /&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;POST &lt;br /&gt; (2-1). 서버에 데이터를 올리기 위해 설계됨. &lt;br /&gt; (2-2). 전송데이터 크기의 제한이 없음.(대용량) &lt;br /&gt; (2-3). 데이터를 요청메시지의 body에 담아 전송. &lt;br /&gt; (2-4). GET에 비해 보안에 유리한 편, 데이터 공유에는 GET보다 불리. &lt;br /&gt; (+)HTTPS = HTTP + TLS &lt;br /&gt; ex) 게시판에 글쓰기, 로그인, 회원가입. &lt;br /&gt;&lt;/p&gt; &lt;/li&gt; &lt;/ol&gt; &lt;h1 id=&quot;바이너리-파일binary-file&quot;&gt;바이너리 파일(Binary File)&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;문자와 숫자가 저장되어 있는 파일. &lt;br /&gt;&lt;/li&gt; &lt;li&gt;데이터를 있는 그대로 읽고 쓴다. &lt;br /&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h1 id=&quot;텍스트-파일text-file-&quot;&gt;텍스트 파일(Text File) =&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;문자만 저장되어 있는 파일. &lt;br /&gt;&lt;/li&gt; &lt;li&gt;숫자를 문자로 변환 후 쓴다. &lt;br /&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h1 id=&quot;mimf-multipurpose-internet-mail-extensions&quot;&gt;MIMF (Multipurpose Internet Mail Extensions)&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;텍스트 기반 프로토콜에 바이너리 데이터 전송하기 위해 고안. &lt;br /&gt;&lt;/li&gt; &lt;li&gt;HTTP Content-Type헤더에 사용, 데이터 타입을 명시.&lt;br /&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;💡&lt;/p&gt; </description><pubDate>Wed, 15 Jun 2022 22:20:51 +0900</pubDate><link>http://localhost:4000/posts/spring-http(2)/</link><guid isPermaLink="true">http://localhost:4000/posts/spring-http(2)/</guid> <category>http</category> <category>spring</category> <category>Study</category> <category>Http</category> <category>Spring</category> </item> <item><title>[Spring] Spring - HTTP(1)</title><description>&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/64628448/173368063-e326ec44-d5c9-4932-afaa-9fab1b072633.png&quot; alt=&quot;spring&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt; &lt;h1 id=&quot;-introduction&quot;&gt;📚 Introduction&lt;/h1&gt; &lt;p&gt;앞으로 복습할 내용들은 SpringMVC를 이용해 간단한 게시판과 웹사이트를 만들어 볼 계획이고, &lt;br /&gt; 다시 복습하면서 학습했던 내용들을 간단히 기록해놓으려고 한다. &lt;br /&gt;&lt;/p&gt; &lt;h1 id=&quot;1&quot;&gt;(1)&lt;/h1&gt; &lt;p&gt;오늘은 클라이언트와 서버가 대략 무엇인지, 어떻게 동작하는지에 대해 간단히 훑어보았다. &lt;br /&gt; 클라이언트는 우리가 매일 사용하는 컴퓨터, 즉, 서비스를 이용하고자 하는 개체라고 보면 될 것 같고, &lt;br /&gt; 서버는 개체들이 원하는 서비스를 제공하는 일종의 집합(?)이라고 해야하나? 쉽게 말하면 손님과 가게 사장 같은 관계로 이해했다. &lt;br /&gt;&lt;/p&gt; &lt;p&gt;아래 이미지는 SpringMVC를 학습하기전에 Servlet이 어떻게 데이터를 주고받는지에 대한 예시이다. &lt;br /&gt; &lt;img src=&quot;https://user-images.githubusercontent.com/64628448/173360075-11600e81-7968-49cc-b62b-d0f7ce25a537.png&quot; alt=&quot;http&quot; /&gt; &lt;br /&gt; “/” 로 구분해주고, 파라미터는 “?”뒤에 Key-Value 형태로 붙여준다. 여러개를 붙일 때는 “&amp;amp;”를 사용한다. &lt;br /&gt;&lt;/p&gt; &lt;p&gt;만약 여러개를 보내는데, Key가 모두 같을 경우, 아래와 같이 하면 된다. &lt;br /&gt; &lt;img src=&quot;https://user-images.githubusercontent.com/64628448/173360289-346a5de7-7e6d-4103-a975-6fcc85c44f8c.png&quot; alt=&quot;http&quot; /&gt; &lt;br /&gt;&lt;/p&gt; &lt;h1 id=&quot;2&quot;&gt;(2)&lt;/h1&gt; &lt;p&gt;만약 하나의 클라이언트가 각자 다른 서비스를 제공하는 여러개의 서버가 있을 경우, &lt;br /&gt; IP주소 만으로는 어떤 서버를 호출하는지 알 수가 없다. -&amp;gt; 이 때, port번호로 구분한다. &lt;br /&gt;&lt;/p&gt; &lt;h1 id=&quot;3&quot;&gt;(3)&lt;/h1&gt; &lt;p&gt;WAS란? (Web Application Server) &lt;br /&gt; =&amp;gt; 프로그램을 서버에 설치하고, 클라이언트들은 서버로 원격프로그램을 호출해서 실행결과만 전송해서 클라이언트들에게 편의성을 제공. &lt;br /&gt; – 과거에는 클라이언트에 프로그램을 설치해서 사용. -&amp;gt; update가 불편. -&amp;gt; 서버 하나에만 설치해서 서버는 update만 하면 된다. &lt;br /&gt;&lt;/p&gt; &lt;p&gt;💡&lt;/p&gt; </description><pubDate>Mon, 13 Jun 2022 22:48:51 +0900</pubDate><link>http://localhost:4000/posts/spring-http(1)/</link><guid isPermaLink="true">http://localhost:4000/posts/spring-http(1)/</guid> <category>http</category> <category>spring</category> <category>Study</category> <category>Http</category> <category>Spring</category> </item> <item><title>[Git] Git / GitHub Flow</title><description>&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/64628448/155834033-6e1dbb9a-3531-47c9-805f-6ed3ffa34702.png&quot; alt=&quot;git&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt; &lt;h1 id=&quot;-introduction&quot;&gt;📚 Introduction&lt;/h1&gt; &lt;p&gt;업무시간 이외에 혼자서 간단한 토이프로젝트를 시작해볼까 고민하던 찰나, &lt;br /&gt; 지인들과 토이프로젝트를 같이 하게 되었다. 👍🙌 &lt;br /&gt; 전에 git의 기본개념과 git &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GUI&lt;/code&gt;에 대한 대략적인 사용방법에 대해서만 한 번 훑어보기만 했었는데, &lt;br /&gt; 이번 프로젝트를 통해서 git을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CLI&lt;/code&gt; 환경에서 사용하는데에 조금이나마 익숙해질 수 있는 기회가 될 것 같다. 🤩&lt;/p&gt; &lt;p&gt;프로젝트 협업 시, &lt;br /&gt; 알아 두면 좋을 것 같은 첫 번째가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git&lt;/code&gt;을 통한 work-flow라고 생각이 들어서, &lt;br /&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git flow&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;github flow&lt;/code&gt;에 대해 간단히 정리를 해보았다. 📕&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;작성중&lt;/p&gt; &lt;/blockquote&gt; &lt;h1 id=&quot;-git-flow&quot;&gt;💥 Git Flow&lt;/h1&gt; &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/64628448/160983901-3d1734da-c365-4559-b349-eb029173a0b1.png&quot; alt=&quot;git_flow&quot; /&gt;&lt;/p&gt; &lt;h1 id=&quot;-github-flow&quot;&gt;💥 GitHub Flow&lt;/h1&gt; &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/64628448/160983209-0bb0998f-271d-4e1f-9a84-501331d7534b.png&quot; alt=&quot;github_flow&quot; /&gt;&lt;/p&gt; &lt;p&gt;💡&lt;/p&gt; </description><pubDate>Thu, 31 Mar 2022 09:35:51 +0900</pubDate><link>http://localhost:4000/posts/git-github-flow/</link><guid isPermaLink="true">http://localhost:4000/posts/git-github-flow/</guid> <category>git</category> <category>Study</category> <category>Git</category> </item> <item><title>[Algorithm] (2) 정수의 자릿수 구하기</title><description>&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/64628448/156101894-2c24e063-ab4f-4421-9a2e-a63f1e22eed7.png&quot; alt=&quot;Algorithm&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt; &lt;h1 id=&quot;-introduction&quot;&gt;📚 Introduction&lt;/h1&gt; &lt;p&gt;오늘은 간단하게 ! &lt;br /&gt; 정수의 자릿수는 어떻게 구할까?&lt;/p&gt; &lt;h1 id=&quot;-log&quot;&gt;💥 log()&lt;/h1&gt; &lt;p&gt;Math클래스의 log 함수를 이용하면 자릿수를 구할 수 있다. &lt;br /&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;log(x)&lt;/code&gt; 는 밑이 e (2.718…)인 자연로그 함수이다. &lt;br /&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;log10()&lt;/code&gt; 는 밑이 10인 로그함수이다. &lt;br /&gt;&lt;/p&gt; &lt;p&gt;그렇다면 정수의 자릿수는 어떻게 구할까? &lt;br /&gt; log10() 함수를 이용한 예시를 보면, &lt;br /&gt;&lt;/p&gt; &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1 2 3 &lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Math.log10(10) // 1.0 Math.log10(100) // 2.0 Math.log10(1000) // 3.0 &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;p&gt;&lt;img width=&quot;339&quot; alt=&quot;스크린샷 2022-03-12 14 27 45&quot; src=&quot;https://user-images.githubusercontent.com/64628448/158005209-ae4c3c58-9aa8-4ee7-b017-63dd6bee7ccd.png&quot; /&gt;&lt;/p&gt; &lt;p&gt;해당 값이 어떻게 나오는지 위 예시코드와 사진을 보면 이해가 될 것이다. &lt;br /&gt;&lt;/p&gt; &lt;p&gt;log10() 함수가 double형으로 값을 리턴하니까, 이를 int형으로 변환한 후, 1을 더해주면 정수값의 자릿수를 얻을 수 있다. &lt;br /&gt;&lt;/p&gt; &lt;p&gt;끝 !&lt;/p&gt; </description><pubDate>Sat, 12 Mar 2022 14:42:35 +0900</pubDate><link>http://localhost:4000/posts/algorithm-logFunc/</link><guid isPermaLink="true">http://localhost:4000/posts/algorithm-logFunc/</guid> <category>java</category> <category>algorithm</category> <category>Study</category> <category>Algorithm</category> </item> <item><title>[Algorithm] (1) 가우스의 덧셈</title><description>&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/64628448/156101894-2c24e063-ab4f-4421-9a2e-a63f1e22eed7.png&quot; alt=&quot;Algorithm&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt; &lt;h1 id=&quot;-introduction&quot;&gt;📚 Introduction&lt;/h1&gt; &lt;p&gt;프로그래밍을 자바로 시작했지만, 일을 하면서 SQL과 JS만 중점적으로 사용하다보니, 기억이 가물가물해졌다. &lt;br /&gt; 앞으로 자바를 이용한 기본적인 알고리즘을 기초부터 공부를 해볼 생각이다. &lt;br /&gt; 병행으로 스프링도 처음부터 개념을 다져봐야겠다. &lt;br /&gt;&lt;/p&gt; &lt;h1 id=&quot;-가우스의-덧셈&quot;&gt;💥 가우스의 덧셈&lt;/h1&gt; &lt;p&gt;1부터 n까지의 합을 구하는 것은 for문와 while문을 사용하면 쉽게 구할 수 있다. &lt;br /&gt; 대입 값이 작은 경우 차이는 별로 없을 것 같지만, 숫자가 커질수록 연산횟수가 많아진다는 점에서 단점이라면 단점일수도 있겠구나하는 생각도 들었다.&lt;br /&gt;&lt;/p&gt; &lt;p&gt;(가우스덧셈에 대한 일화는 나중에 심심풀이로 찾아보기로 하고,) &lt;br /&gt;&lt;/p&gt; &lt;p&gt;가우스 덧셈을 그림으로 보면 아래와 같다. &lt;br /&gt; 1부터 하나씩 차례차례 더해주는것이 아니라, 맨 앞자리 숫자와 맨 끝자리 숫자를 더한 값이 두번째 숫자와 끝에서 두번째 숫자의 합과 같다는 것을 볼 수 있다.&lt;br /&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/64628448/156102575-59a0d64a-2083-4dfa-b013-f9b0d12009ae.png&quot; alt=&quot;gauss&quot; /&gt;&lt;/p&gt; &lt;p&gt;n이 짝수일 경우, n을 2로 나누고 맨 앞자리 숫자와 맨 끝자리 숫자를 더한 값을 곱해주면 예쁘게 맞아 떨어지겠지만, &lt;br /&gt; 주어진 값이 홀수일 경우, 중간 값이 남는다. &lt;br /&gt; 이때는 2로 나누어 떨어지는 부분은 모두 더해주고, 중간값인 홀수인 부분을 추가로 더해줘야 한다. &lt;br /&gt;&lt;/p&gt; &lt;p&gt;이를 코드로 나타내면 다음과 같다. &lt;br /&gt;&lt;/p&gt; &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1 2 3 4 5 &lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;int sum = (n+1)*(n/2); if (n%2 != 0) { sum += (n+1) / 2; } &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;p&gt;&lt;br /&gt; 변수 sum에는 맨 앞자리 숫자와 맨 끝자리 숫자를 더한 값에 n을 2로 나눈 값을 곱해준다. &lt;br /&gt; if문은 주어진 값이 홀수일 경우, 중간에 남는 값을 더해준다.&lt;/p&gt; &lt;p&gt;삼항연산자를 이용하면, &lt;br /&gt;&lt;/p&gt; &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1 &lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;int sum = (n+1) * (n/2) + (n%2 == 0 ? 0 : (n+1) / 2); &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;p&gt;이다. &lt;br /&gt;&lt;/p&gt; </description><pubDate>Tue, 01 Mar 2022 14:17:59 +0900</pubDate><link>http://localhost:4000/posts/algorithm-gauss/</link><guid isPermaLink="true">http://localhost:4000/posts/algorithm-gauss/</guid> <category>java</category> <category>algorithm</category> <category>Study</category> <category>Algorithm</category> </item> <item><title>[Git] Git - etc</title><description>&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/64628448/155834033-6e1dbb9a-3531-47c9-805f-6ed3ffa34702.png&quot; alt=&quot;git&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt; &lt;h1 id=&quot;-introduction&quot;&gt;📚 Introduction&lt;/h1&gt; &lt;p&gt;좋은 커밋 메세지의 7가지 규칙.&lt;/p&gt; &lt;p&gt;&lt;br /&gt;&lt;/p&gt; &lt;h1 id=&quot;-좋은-커밋-메세지의-7가지-규칙&quot;&gt;💡 좋은 커밋 메세지의 7가지 규칙&lt;/h1&gt; &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1 2 3 4 5 6 7 &lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;1. 제목과 본문을 빈 줄로 분리한다. 2. 제목은 50자 이내로 작성한다. 3. 제목을 영어로 작성할 경우, 첫 글자는 대문자로 작성한다. 4. 제목에는 마침표를 작성하지 않는다. 5. 제목을 영어로 작성할 경우, 동사원형(현재형)으로 시작한다. 6. 본문을 72자 단위로 줄바꿈한다. 7. How보다 What과 Why를 설명한다. &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;h2 id=&quot;-etc&quot;&gt;💡 etc&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git status&lt;/code&gt; → clean하다. → working tree = stage = HEAD. &lt;br /&gt; ( 3 작업공간의 이력이 일치한다. 즉, 세 작업공간의 커밋 내용이 모두 똑같다. ) &lt;br /&gt; ( 변화가 없다. )&lt;/li&gt; &lt;/ul&gt; </description><pubDate>Sat, 26 Feb 2022 17:41:07 +0900</pubDate><link>http://localhost:4000/posts/git-git-etc/</link><guid isPermaLink="true">http://localhost:4000/posts/git-git-etc/</guid> <category>git</category> <category>sourcetree</category> <category>Study</category> <category>Git</category> </item> <item><title>[Git] Git (6) - stash</title><description>&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/64628448/155834033-6e1dbb9a-3531-47c9-805f-6ed3ffa34702.png&quot; alt=&quot;git&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt; &lt;h1 id=&quot;-introduction&quot;&gt;📚 Introduction&lt;/h1&gt; &lt;p&gt;커밋을 만들지 않고, 변경사항을 잠시 서랍(?) 속에 저장할 수 있는 stash의 기본 개념과 사용법에 대해서 알아보자. &lt;br /&gt;&lt;/p&gt; &lt;h1 id=&quot;-git-stash-란&quot;&gt;💥 Git stash 란?&lt;/h1&gt; &lt;blockquote&gt; &lt;p&gt;변경사항을 잠시 다른 곳에 저장하고 싶어요, 커밋은 만들지 않을래요 !&lt;br /&gt;&lt;/p&gt; &lt;/blockquote&gt; &lt;blockquote&gt; &lt;p&gt;커밋하지 않은 변경사항을 서랍(?) 속에 넣어두기.&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;br /&gt;&lt;/p&gt; &lt;h1 id=&quot;-sourcetree에서-진행하기&quot;&gt;💥 SourceTree에서 진행하기.&lt;/h1&gt; &lt;ol&gt; &lt;li&gt;History → &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stash&lt;/code&gt;하고 싶은 커밋을 선택 후, 상단 스태시 탭을 선택한다.&lt;/li&gt; &lt;li&gt;스태시에 대한 설명을 적고 확인을 선택한다.&lt;/li&gt; &lt;li&gt;저장된 스태시를 꺼내려면 왼쪽 사이드바의 스태시 섹션에서 원하는 스태시를 선택하고, 우클릭한 후, 스태시 적용을 선택한다.&lt;/li&gt; &lt;li&gt;스태시했던 변경사항이 스테이지로 튀어나온 것을 확인할 수 있다.&lt;/li&gt; &lt;/ol&gt; &lt;p&gt;💡 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stash&lt;/code&gt;에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tracked 상태&lt;/code&gt; (추적 중 - Git에 한번이라도 올렸던 상태) 인 파일들만 들어간다. &lt;br /&gt; 새로만든 파일은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;untracked&lt;/code&gt; 상태라 들어가지 않는다.&lt;/p&gt; </description><pubDate>Sat, 26 Feb 2022 17:35:51 +0900</pubDate><link>http://localhost:4000/posts/git-git-stash/</link><guid isPermaLink="true">http://localhost:4000/posts/git-git-stash/</guid> <category>git</category> <category>sourcetree</category> <category>Study</category> <category>Git</category> </item> <item><title>[Git] Git (5) - reset, revert</title><description>&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/64628448/155834033-6e1dbb9a-3531-47c9-805f-6ed3ffa34702.png&quot; alt=&quot;git&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt; &lt;h1 id=&quot;-introduction&quot;&gt;📚 Introduction&lt;/h1&gt; &lt;p&gt;예전 커밋으로 브랜치를 되돌리는 reset과 비슷한 개념인 revert의 기본 개념과 사용법을 알아보자.&lt;/p&gt; &lt;h1 id=&quot;-git-reset-이란&quot;&gt;💥 Git reset 이란?&lt;/h1&gt; &lt;blockquote&gt; &lt;p&gt;예전 커밋으로 브랜치를 되돌리고 싶어요 ! &lt;br /&gt;&lt;/p&gt; &lt;/blockquote&gt; &lt;h1 id=&quot;-sourcetree에서-진행하기&quot;&gt;💥 SourceTree에서 진행하기.&lt;/h1&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Soft / Mixed reset&lt;/code&gt; ⇒&lt;/p&gt; &lt;p&gt;모든 이력을 남기면서 브랜치를 되돌리기.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Soft와 Mixed의 차이점 ⇒ &lt;br /&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[Mixed]&lt;/code&gt;는 변경사항을 스테이지 아래로 내려서 다시 무엇을 스테이지 위로 Add 할지 고민할 수 있고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[Soft]&lt;/code&gt;는 변경사항을 스테이지 위로 올려서 다시 당장 커밋할 수 있다는 차이점이 있다.&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hard reset&lt;/code&gt; ⇒&lt;/p&gt; &lt;p&gt;모든 이력을 지우며 브랜치를 되돌리기.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;현재 브랜치가 어디에 있던지, 커밋하지 않은 변경사항이 얼마나 있는지와 상관없이 어디로든 깔끔하게 이동할 수 있다.&lt;/li&gt; &lt;li&gt;공통 브랜치에서 ( 강제 푸쉬 = History를 수정하는 푸쉬 )를 하면 히스토리가 꼬일 수 있기 때문에, 반드시 자신 혼자만 사용하는 브랜치에서 사용해야 한다.&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h1 id=&quot;-git-revert-란&quot;&gt;💥 Git revert 란?&lt;/h1&gt; &lt;blockquote&gt; &lt;p&gt;커밋 잘못했는데, 이 커밋의 변경사항을 되돌리고 싶어요 !&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;🛎 방금 한 커밋 만이 아니라, 이전에 한 커밋도 되돌릴 수 있다 ! &lt;br /&gt;&lt;/p&gt; &lt;h1 id=&quot;-sourcetree에서-진행하기-1&quot;&gt;💥 SourceTree에서 진행하기.&lt;/h1&gt; &lt;ol&gt; &lt;li&gt;History → 되돌리고 싶은 커밋 우 선택한다.&lt;/li&gt; &lt;li&gt;커밋 되돌리기를 선택한다.&lt;/li&gt; &lt;/ol&gt; &lt;h1 id=&quot;-reset보다-revert-&quot;&gt;💥 reset보다 revert ?&lt;/h1&gt; &lt;p&gt;💡 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reset&lt;/code&gt;으로 커밋을 아무도 모르게 없앨 수도 있지만, &lt;br /&gt; 여러 사람들과 협업하고 있고, 이력 관리가 중요하다면,&lt;br /&gt; 잘못된 커밋을 없애는 것보다 변경 사항을 되돌리는 새로운 커밋을 만드는게 더 좋다.&lt;/p&gt; </description><pubDate>Sat, 26 Feb 2022 17:29:16 +0900</pubDate><link>http://localhost:4000/posts/git-git-reset-revert/</link><guid isPermaLink="true">http://localhost:4000/posts/git-git-reset-revert/</guid> <category>git</category> <category>sourcetree</category> <category>Study</category> <category>Git</category> </item> </channel> </rss>
